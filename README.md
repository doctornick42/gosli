# gosli

### **Tedious intro**:
Please, let me describe why I decided to implement this package and which problems should it solve.

The goal of this library is to make easier to work with slices in Go. It's inspired by .NET LINQ query language.

Since Go doesn't have generic methods, we have to write all these `for` loops for every type we work with. And this routine takes a huge amount of time and it's not very fun to wright almost the same loops again and again. 

gosli doesn't use `reflect` package at all because preformance really matters for the most of golang applications, and `reflect` is considered to be slow.

So, after all, the good way to avoid using reflection is to implement some code generator. And here comes gosli.

---

### **Quickstart**

Ok, let's start. We need to get gosli and to install it to our GOPATH/bin folder. All we need to do is run:
```
go get github.com/doctornick42/gosli
```

Then, for example we have a file in our project `example/faketype.go`. And it contains a structure called `FakeType`.

Run:
```
GOPATH/gosli example/faketype.go FakeType
```
Ok, if you're using Windows, of course it should be `gosli.exe` instead of `gosli`.

This command will generate two files:
```
example/faketype_generated.go
example/faketype_equal.go
```

`faketype_generated.go` contains all the methods that gosli provides to use. This file shouldn't be edited manually.

In turn, `faketype_equal.go` has to be updated by you! After it's generated it contains the only method with empty body:

```go
func (r *FakeType) equal(another *FakeType) bool {
	// `equal` method has to be implemented manually
}
```

In this method we should tell gosli how it should understand if two instances of a structure are equal. You can expect them to be equal, for example, if all of their fields are equal, or some `id` fields only matter. Anyway, you could implement this method whatever you like. Just remember, `equal` method works in methods `Contains`, `GetUnion` and `InFirstOnly`.

Example:
```go
func (r *FakeType) equal(another *FakeType) bool {
    // `equal` method has to be implemented manually
    return r.A == another.A &&
        r.B == another.B
}
```

That's it, now you can use the methods generated by gosli for your type. If our type's name is `FakeType` then `FakeTypeSlice()` is generated and we can use the methods like that:
```go
FakeTypeSlice().First(sl, filter)
```

Let's look on the methods list.

---
## **Methods**


* ### First
    Returns first item of a slice that is passed through a filter.

    If an item wasn't found, the method returns an error.
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    filter = func(t *FakeType) bool {
        return t.A == 2
    }
    res, err := FakeTypeSlice().First(sl, filter)

    //res = &FakeType{
    //    A: 2,
    //    B: "two",
    //} 
    ```

* ### FirstOrDefault
    Returns first item of a slice that is passed through a filter.

    If an item wasn't found, the result is nil.
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    filter = func(t *FakeType) bool {
        return t.A == 2
    }
    res, err := FakeTypeSlice().FirstOrDefault(sl, filter)

    //res = &FakeType{
    //    A: 2,
    //    B: "two",
    //} 
    ```

* ### Where
    Returns all items of a slice that is passed through a filter.

    If items weren't found, the result is empty slice.
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    filter = func(t *FakeType) bool {
        return t.A >= 2
    }
    res, err := FakeTypeSlice().Where(sl, filter)

    //res = []*FakeType{
	//    &FakeType{
    //        A: 2,
    //        B: "two",
    //    },
    //    &FakeType{
    //        A: 3,
    //        B: "three",
    //    },
    //} 
    ```

* ### Select
    Applies a function to every item of a slice and returns slice of results.
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    f := func(t *FakeType) interface{} {
        return struct {
            Msg string
        }{
            Msg: t.B,
        }
    }
    res, err := FakeTypeSlice().Select(sl, f)

    //res = []struct {
	//    Msg string
	//}{
    //    {
    //        Msg: "one",
    //    },
    //    {
    //        Msg: "two",
    //    },
    //    {
    //        Msg: "three",
    //    },
	//} 
    ```

* ### Page
    Returns paginated slice according to given `number` (number of selected page) and `perPage` 
    (items per a page). `number` parameter should start with 1 (not 0).
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    res, err := FakeTypeSlice().PerPage(sl, 1, 2)

    //res = []*FakeType
    //    &FakeType{
    //        A: 1,
    //        B: "one",
	//    },
    //    &FakeType{
    //        A: 2,
    //        B: "two",
    //    },
	//} 
    ```

* ### Any
    Returns `true` if any item of the slice is passed through a filter.

    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }
    
    filter = func(t *FakeType) bool {
        return t.A == 2
    }
    res, err := FakeTypeSlice(sl).Any(filter)

    //res = true
    ```

* ### Contains
    Returns `true` if a slice contains at least one item that is equal to the desired one.
    
    ```go
    sl := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }

    el := &FakeType{
        A: 2,
        B: "two",
    }
    
    res, err := FakeTypeSlice().Contains(sl, el)

    //res = true
    ```

* ### GetUnion
    Returns a slice that contains items that are contained in both given slices.
    
    ```go
    sl1 := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }

    sl2 := []*FakeType{
	    &FakeType{
            A: 2,
            B: "two",
	    },
        &FakeType{
            A: 3,
            B: "three",
        },
        &FakeType{
            A: 4,
            B: "four",
        },
    }

    res, err := FakeTypeSlice().GetUnion(sl1, sl2)

    //res = []*FakeType{
	//    &FakeType{
    //        A: 2,
    //        B: "two",
	//    },
    //    &FakeType{
    //        A: 3,
    //        B: "three",
    //    },
    //} 
    ```

* ### InFirstOnly
    Returns elements that are contained only in a first slice and is not contained in a second one.
    
    ```go
    sl1 := []*FakeType{
	    &FakeType{
            A: 1,
            B: "one",
	    },
        &FakeType{
            A: 2,
            B: "two",
        },
        &FakeType{
            A: 3,
            B: "three",
        },
    }

    sl2 := []*FakeType{
	    &FakeType{
            A: 2,
            B: "two",
	    },
        &FakeType{
            A: 3,
            B: "three",
        },
        &FakeType{
            A: 4,
            B: "four",
        },
    }

    res, err := FakeTypeSlice().InFirstOnly(sl1, sl2)

    //res = []*FakeType{
	//    &FakeType{
    //        A: 1,
    //        B: "one",
	//    },
    //} 
    ```

#### If the description looks unclear for you, please take a look at [`experiment` folder](https://github.com/doctornick42/gosli/tree/master/experiment). You can find there unit test, benchmarks and some generated code that could describe the essent of the library much better than my poor English :)
